#!/bin/python3
import sys
import json
import shutil
import os
import subprocess
import random
import time


from os import listdir
from os.path import isfile, join, basename ,splitext
from os import walk



def nonSymbTrialGen(numbers=[i for i in range(5,22)], buckets = [{'min':1.18,'max':1.25},{'min':1.3,'max':1.32},{'min':1.9,'max':2.1},{'min':3,'max':3.4}]):
    '''
    returns a dict with the fields that are needed. it does not however tell you the filename!
    '''

    all_matchings = []
    for left_num in numbers:
        for right_num in numbers:
            # no same things.
            if(left_num == right_num):
                continue
            higher_num = max(left_num,right_num)
            lower_num = min(left_num,right_num)
            this_match = {"left_num":left_num,"right_num":right_num,"solution":higher_num,"ratio":round(higher_num/lower_num,2)}
            
            this_match['bucket'] = -1
            for bucket_index in range(0,len(buckets)):
                bucket = buckets[bucket_index]
                if this_match['ratio'] <= bucket['max'] and this_match['ratio'] >= bucket['min']:
                    this_match['bucket'] = bucket_index
            # if it does not fit into a bucket we dont need it.
            if(this_match['bucket'] == -1):
                continue

            all_matchings.append(this_match)

    return all_matchings


def genNonSymbTrials():
    '''
    this function knows  how to name the files and what to do with the trials generated by nonsymTrialGen
    '''
    all_matchings = nonSymbTrialGen()
    ids_area_control = [i for i in range(0,17)]
    ids_radius_control = [i for i in range(17,34)]
    # we have each match 2 times. once for the area controlled and another time for the radius.
    min_n_dots = 5
    trials = []
    for match_index in range(0,len(all_matchings)):
        match = all_matchings[match_index]
        left_num = match['left_num']
        right_num = match['right_num']
        solution_num = match['solution']

        left_filename_area = "id_"+str(ids_area_control[left_num-min_n_dots])+"_dots_"+str(left_num)+".png"
        right_filename_area = "id_"+str(ids_area_control[right_num-min_n_dots])+"_dots_"+str(right_num)+".png"
        solution_filename_area = "id_"+str(ids_area_control[solution_num-min_n_dots])+"_dots_"+str(solution_num)+".png"
        trials.append([left_filename_area,right_filename_area,solution_filename_area,match])

        left_filename_radius = "id_"+str(ids_radius_control[left_num-min_n_dots])+"_dots_"+str(left_num)+".png"
        right_filename_radius = "id_"+str(ids_radius_control[right_num-min_n_dots])+"_dots_"+str(right_num)+".png"
        solution_filename_radius = "id_"+str(ids_radius_control[solution_num-min_n_dots])+"_dots_"+str(solution_num)+".png"
        trials.append([left_filename_radius,right_filename_radius,solution_filename_radius,match])



    return trials




def genSymbolicNumberCompareTrials(distances=[1,2,5,6],numbers=[1,2,3,4,5,6,7,8,9]):
    '''
    our output tells us that we have:
    have  8 for distance: 1
    have  7 for distance: 2
    have  4 for distance: 5
    have  3 for distance: 6
    so we use the distance 5 and 6 double to make it more balanced
    '''
    trials = []
    for dist in distances:
        dist_poss_count = 0
        for num in numbers:
            left_num = num
            right_num = num+dist
            solution = max(left_num,right_num)
            if (not left_num in numbers) or (not right_num in numbers):
                continue
            # append both directions
            trials.append([left_num,right_num,solution,dist])
            trials.append([right_num,left_num,solution,dist])
            dist_poss_count +=1
        print("have ",dist_poss_count,"for distance:",dist)
    return trials

def genOrdinalNumberVerificationTrials(distances=[1,2,3],numbers=[1,2,3,4,5,6,7,8,9]):
    '''
    our output tells us that we have:
    have  7 for distance: 1
    have  5 for distance: 2
    have  3 for distance: 3
    so we use the distance 3 ones double to make it more balanced
    '''
    trials = []

    for dist in distances:
        dist_poss_count = 0
        for num in numbers:
            left_num = num
            mid_num = num+dist
            right_num = num+2*dist
            solution = "IN_ORDER"
            if (not left_num in numbers) or (not mid_num in numbers) or (not right_num in numbers):
                continue
            # append both directions
            trials.append([left_num,mid_num,right_num,solution])
            trials.append([right_num,mid_num,left_num,solution])

            solution = "MIXED_ORDER"
            # ascending mixed
            trials.append([mid_num,right_num,left_num,solution])
            #descending mixed
            trials.append([mid_num,left_num,right_num,solution])
            dist_poss_count +=1
        print("have ",dist_poss_count,"for distance:",dist)
        


    return trials

def genNumLineTrials(ranges=[x for x in range(32,64+1,6)],targets=[x for x in range(4,32+1,3)]):
    '''
    our output tells us that we have:
    so we use the distance 3 ones double to make it more balanced
    '''
    trials = []

    for rang in ranges:
        for num in targets:
            trials.append([rang,num])

    return trials


def getPossibleMatchings(numbers_left=[2,3,4,5,6,7,8,9],numbers_right=[2,3,4,5,6,7,8,9]):
    matchings = []
    for num_1 in numbers_left:
        for num_2 in numbers_right:
            matchings.append([num_1,num_2])
    return matchings




def genAdditionTrials(numbers=[2,3,4,5,6,7,8,9]):
    '''
    '''
    trials = []

    # single digit numbers
    matchings = getPossibleMatchings(numbers_left=numbers,numbers_right=numbers)
    for match in matchings:
        solution = match[0]+match[1]
        trials.append([match[0],match[1],solution])
    

    two_digit_trials = []
    matchings = getPossibleMatchings(numbers_left=[i for i in range(10,100)],numbers_right=[i for i in range(10,100)])
    for match in matchings:
        solution = match[0]+match[1]
        two_digit_trials.append([match[0],match[1],solution])

    # solution must be 2 digits also 
    two_digit_trials = [i for i in two_digit_trials if not i[2] >= 100]

    # only with "zehnerÃ¼bergang"
    two_digit_trials = [i for i in two_digit_trials if ((i[0]%10) + (i[1]%10))>10]

    # ignore stuff with the same last digit (66+36,...)
    two_digit_trials = [i for i in two_digit_trials if not (i[0]%10) == (i[1]%10)]

    # ignore numbers with same digits (55,66,...) 
    two_digit_trials = [i for i in two_digit_trials if not (((i[0]%10) == ((i[0]//10)%10)) or ((i[1]%10) == ((i[1]//10)%10)) or ((i[2]%10) == ((i[2]//10)%10)))]

    print("len two digits.",len(two_digit_trials))
    n_two_digits = 60
    two_digit_trials = random.sample(two_digit_trials,n_two_digits)

    

    # no same operants
    trials = [i for i in trials if not i[0] == i[1]]

    trials = trials + two_digit_trials
    return trials

def genMultiplicationTrials(numbers = [2,3,4,5,6,7,8,9]):
    trials = []
    for num_1 in numbers:
        for num_2 in numbers:
            if(num_1 == num_2):
                continue
            solution = num_1*num_2
            trials.append([num_1,num_2,solution])

    two_digit_trials = getPossibleMatchings(numbers_left=[i for i in range(12,100)],numbers_right=[i for i in range(3,10)])
    for numbers in two_digit_trials:
        # add the mult result.
        numbers.append(numbers[0]*numbers[1])


    #two_digit_trials = [i for i in two_digit_trials if not (i[0] == i[1])]
    two_digit_trials = [i for i in two_digit_trials if (i[2] < 100)]
    #two_digit_trials = [i for i in two_digit_trials if not (((i[0]%10) == ((i[0]//10)%10)) or ((i[1]%10) == ((i[1]//10)%10)) or ((i[2]%10) == ((i[2]//10)%10)))]

    print("len two digits.",len(two_digit_trials))

    #n_two_digits = 60
    #two_digit_trials = random.sample(two_digit_trials,n_two_digits)

    

    return trials + two_digit_trials


def genSubtractionTrials(numbers= [2,3,4,5,6,7,8,9]):
    trials = genAdditionTrials(numbers)
    for trial in trials:
        # swap the solution with the first operant
        print(trial)
        temp = trial[0]
        trial[0] = trial[2]
        trial[2] = temp

    return trials

def genTypingTrials(numbers=[x for x in range(1,100)]):
    '''
    '''
    trials = []

    for num_1 in numbers:
        solution = num_1
        trials.append([num_1,solution])

    return trials








def insertListIntoTemplate(template_string,numbers_list):
    '''
    insertLIstIntoTemplate
    inserts a list into a template
    the template string needs to have the spots marked with INSERT_HERE_0,INSERT_HERE_1,...
    @ret the string with everything replaced.
    '''
    for index in range(0,len(numbers_list)):
        template_string = template_string.replace("INSERT_HERE_"+str(index),str(numbers_list[index]))
    return template_string







def main():

    if (len(sys.argv) != 3):
        print("invalid number of args. quitting...")
        print("sys argv:",sys.argv)
        quit()


    # in order to get replicable results we use a random seed
    #random.seed(42)
    mode = sys.argv[1]
    if(mode == "symb"):
        trials = genSymbolicNumberCompareTrials()
    elif mode == "ord":
        trials = genOrdinalNumberVerificationTrials()
    elif mode == "numline":
        trials = genNumLineTrials()
    elif mode == "add":
        trials = genAdditionTrials()
    elif mode == "sub":
        trials = genSubtractionTrials()
    elif mode == "mult":
        trials = genMultiplicationTrials()
    elif mode == "speed":
        trials = genTypingTrials()
    elif mode == "nonsymb":
        trials = genNonSymbTrials()

    template_file = sys.argv[2]

    temp_string = ""
    with open(template_file) as tempfile:
        temp_string = tempfile.read()

    string_with_all_trials = ""
    for trial in trials:
        string_with_all_trials += insertListIntoTemplate(temp_string,trial)
    
    print(string_with_all_trials)
    






        

if __name__ == "__main__":
    main()
    
